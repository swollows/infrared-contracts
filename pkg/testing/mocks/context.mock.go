// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/berachain/offchain-sdk/log"
	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/ethdb"
	"github.com/ethereum/go-ethereum/rpc"
	"math/big"
	"sync"
)

// Ensure, that EthClientMock does implement EthClient.
// If this is not the case, regenerate this file with moq.
var _ EthClient = &EthClientMock{}

// EthClientMock is a mock implementation of EthClient.
//
//	func TestSomethingThatUsesEthClient(t *testing.T) {
//
//		// make and configure a mocked EthClient
//		mockedEthClient := &EthClientMock{
//			BalanceAtFunc: func(ctx context.Context, account common.Address, blockNumber *big.Int) (*big.Int, error) {
//				panic("mock out the BalanceAt method")
//			},
//			BlockByNumberFunc: func(ctx context.Context, number *big.Int) (*types.Block, error) {
//				panic("mock out the BlockByNumber method")
//			},
//			BlockNumberFunc: func(ctx context.Context) (uint64, error) {
//				panic("mock out the BlockNumber method")
//			},
//			BlockReceiptsFunc: func(ctx context.Context, blockNrOrHash rpc.BlockNumberOrHash) ([]*types.Receipt, error) {
//				panic("mock out the BlockReceipts method")
//			},
//			CallContractFunc: func(ctx context.Context, msg ethereum.CallMsg, blockNumber *big.Int) ([]byte, error) {
//				panic("mock out the CallContract method")
//			},
//			ChainIDFunc: func(ctx context.Context) (*big.Int, error) {
//				panic("mock out the ChainID method")
//			},
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			CodeAtFunc: func(ctx context.Context, account common.Address, blockNumber *big.Int) ([]byte, error) {
//				panic("mock out the CodeAt method")
//			},
//			DialFunc: func() error {
//				panic("mock out the Dial method")
//			},
//			EstimateGasFunc: func(ctx context.Context, msg ethereum.CallMsg) (uint64, error) {
//				panic("mock out the EstimateGas method")
//			},
//			FilterLogsFunc: func(ctx context.Context, q ethereum.FilterQuery) ([]types.Log, error) {
//				panic("mock out the FilterLogs method")
//			},
//			HeaderByNumberFunc: func(ctx context.Context, number *big.Int) (*types.Header, error) {
//				panic("mock out the HeaderByNumber method")
//			},
//			PendingCodeAtFunc: func(ctx context.Context, account common.Address) ([]byte, error) {
//				panic("mock out the PendingCodeAt method")
//			},
//			PendingNonceAtFunc: func(ctx context.Context, account common.Address) (uint64, error) {
//				panic("mock out the PendingNonceAt method")
//			},
//			SendTransactionFunc: func(ctx context.Context, tx *types.Transaction) error {
//				panic("mock out the SendTransaction method")
//			},
//			SubscribeFilterLogsFunc: func(ctx context.Context, q ethereum.FilterQuery, ch chan<- types.Log) (ethereum.Subscription, error) {
//				panic("mock out the SubscribeFilterLogs method")
//			},
//			SubscribeNewHeadFunc: func(ctx context.Context) (chan *types.Header, ethereum.Subscription, error) {
//				panic("mock out the SubscribeNewHead method")
//			},
//			SuggestGasPriceFunc: func(ctx context.Context) (*big.Int, error) {
//				panic("mock out the SuggestGasPrice method")
//			},
//			SuggestGasTipCapFunc: func(ctx context.Context) (*big.Int, error) {
//				panic("mock out the SuggestGasTipCap method")
//			},
//			TransactionByHashFunc: func(ctx context.Context, hash common.Hash) (*types.Transaction, bool, error) {
//				panic("mock out the TransactionByHash method")
//			},
//			TransactionReceiptFunc: func(ctx context.Context, txHash common.Hash) (*types.Receipt, error) {
//				panic("mock out the TransactionReceipt method")
//			},
//		}
//
//		// use mockedEthClient in code that requires EthClient
//		// and then make assertions.
//
//	}
type EthClientMock struct {
	// BalanceAtFunc mocks the BalanceAt method.
	BalanceAtFunc func(ctx context.Context, account common.Address, blockNumber *big.Int) (*big.Int, error)

	// BlockByNumberFunc mocks the BlockByNumber method.
	BlockByNumberFunc func(ctx context.Context, number *big.Int) (*types.Block, error)

	// BlockNumberFunc mocks the BlockNumber method.
	BlockNumberFunc func(ctx context.Context) (uint64, error)

	// BlockReceiptsFunc mocks the BlockReceipts method.
	BlockReceiptsFunc func(ctx context.Context, blockNrOrHash rpc.BlockNumberOrHash) ([]*types.Receipt, error)

	// CallContractFunc mocks the CallContract method.
	CallContractFunc func(ctx context.Context, msg ethereum.CallMsg, blockNumber *big.Int) ([]byte, error)

	// ChainIDFunc mocks the ChainID method.
	ChainIDFunc func(ctx context.Context) (*big.Int, error)

	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// CodeAtFunc mocks the CodeAt method.
	CodeAtFunc func(ctx context.Context, account common.Address, blockNumber *big.Int) ([]byte, error)

	// DialFunc mocks the Dial method.
	DialFunc func() error

	// EstimateGasFunc mocks the EstimateGas method.
	EstimateGasFunc func(ctx context.Context, msg ethereum.CallMsg) (uint64, error)

	// FilterLogsFunc mocks the FilterLogs method.
	FilterLogsFunc func(ctx context.Context, q ethereum.FilterQuery) ([]types.Log, error)

	// HeaderByNumberFunc mocks the HeaderByNumber method.
	HeaderByNumberFunc func(ctx context.Context, number *big.Int) (*types.Header, error)

	// PendingCodeAtFunc mocks the PendingCodeAt method.
	PendingCodeAtFunc func(ctx context.Context, account common.Address) ([]byte, error)

	// PendingNonceAtFunc mocks the PendingNonceAt method.
	PendingNonceAtFunc func(ctx context.Context, account common.Address) (uint64, error)

	// SendTransactionFunc mocks the SendTransaction method.
	SendTransactionFunc func(ctx context.Context, tx *types.Transaction) error

	// SubscribeFilterLogsFunc mocks the SubscribeFilterLogs method.
	SubscribeFilterLogsFunc func(ctx context.Context, q ethereum.FilterQuery, ch chan<- types.Log) (ethereum.Subscription, error)

	// SubscribeNewHeadFunc mocks the SubscribeNewHead method.
	SubscribeNewHeadFunc func(ctx context.Context) (chan *types.Header, ethereum.Subscription, error)

	// SuggestGasPriceFunc mocks the SuggestGasPrice method.
	SuggestGasPriceFunc func(ctx context.Context) (*big.Int, error)

	// SuggestGasTipCapFunc mocks the SuggestGasTipCap method.
	SuggestGasTipCapFunc func(ctx context.Context) (*big.Int, error)

	// TransactionByHashFunc mocks the TransactionByHash method.
	TransactionByHashFunc func(ctx context.Context, hash common.Hash) (*types.Transaction, bool, error)

	// TransactionReceiptFunc mocks the TransactionReceipt method.
	TransactionReceiptFunc func(ctx context.Context, txHash common.Hash) (*types.Receipt, error)

	// calls tracks calls to the methods.
	calls struct {
		// BalanceAt holds details about calls to the BalanceAt method.
		BalanceAt []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Account is the account argument value.
			Account common.Address
			// BlockNumber is the blockNumber argument value.
			BlockNumber *big.Int
		}
		// BlockByNumber holds details about calls to the BlockByNumber method.
		BlockByNumber []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Number is the number argument value.
			Number *big.Int
		}
		// BlockNumber holds details about calls to the BlockNumber method.
		BlockNumber []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// BlockReceipts holds details about calls to the BlockReceipts method.
		BlockReceipts []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BlockNrOrHash is the blockNrOrHash argument value.
			BlockNrOrHash rpc.BlockNumberOrHash
		}
		// CallContract holds details about calls to the CallContract method.
		CallContract []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Msg is the msg argument value.
			Msg ethereum.CallMsg
			// BlockNumber is the blockNumber argument value.
			BlockNumber *big.Int
		}
		// ChainID holds details about calls to the ChainID method.
		ChainID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// CodeAt holds details about calls to the CodeAt method.
		CodeAt []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Account is the account argument value.
			Account common.Address
			// BlockNumber is the blockNumber argument value.
			BlockNumber *big.Int
		}
		// Dial holds details about calls to the Dial method.
		Dial []struct {
		}
		// EstimateGas holds details about calls to the EstimateGas method.
		EstimateGas []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Msg is the msg argument value.
			Msg ethereum.CallMsg
		}
		// FilterLogs holds details about calls to the FilterLogs method.
		FilterLogs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Q is the q argument value.
			Q ethereum.FilterQuery
		}
		// HeaderByNumber holds details about calls to the HeaderByNumber method.
		HeaderByNumber []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Number is the number argument value.
			Number *big.Int
		}
		// PendingCodeAt holds details about calls to the PendingCodeAt method.
		PendingCodeAt []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Account is the account argument value.
			Account common.Address
		}
		// PendingNonceAt holds details about calls to the PendingNonceAt method.
		PendingNonceAt []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Account is the account argument value.
			Account common.Address
		}
		// SendTransaction holds details about calls to the SendTransaction method.
		SendTransaction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Tx is the tx argument value.
			Tx *types.Transaction
		}
		// SubscribeFilterLogs holds details about calls to the SubscribeFilterLogs method.
		SubscribeFilterLogs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Q is the q argument value.
			Q ethereum.FilterQuery
			// Ch is the ch argument value.
			Ch chan<- types.Log
		}
		// SubscribeNewHead holds details about calls to the SubscribeNewHead method.
		SubscribeNewHead []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// SuggestGasPrice holds details about calls to the SuggestGasPrice method.
		SuggestGasPrice []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// SuggestGasTipCap holds details about calls to the SuggestGasTipCap method.
		SuggestGasTipCap []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// TransactionByHash holds details about calls to the TransactionByHash method.
		TransactionByHash []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hash is the hash argument value.
			Hash common.Hash
		}
		// TransactionReceipt holds details about calls to the TransactionReceipt method.
		TransactionReceipt []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TxHash is the txHash argument value.
			TxHash common.Hash
		}
	}
	lockBalanceAt           sync.RWMutex
	lockBlockByNumber       sync.RWMutex
	lockBlockNumber         sync.RWMutex
	lockBlockReceipts       sync.RWMutex
	lockCallContract        sync.RWMutex
	lockChainID             sync.RWMutex
	lockClose               sync.RWMutex
	lockCodeAt              sync.RWMutex
	lockDial                sync.RWMutex
	lockEstimateGas         sync.RWMutex
	lockFilterLogs          sync.RWMutex
	lockHeaderByNumber      sync.RWMutex
	lockPendingCodeAt       sync.RWMutex
	lockPendingNonceAt      sync.RWMutex
	lockSendTransaction     sync.RWMutex
	lockSubscribeFilterLogs sync.RWMutex
	lockSubscribeNewHead    sync.RWMutex
	lockSuggestGasPrice     sync.RWMutex
	lockSuggestGasTipCap    sync.RWMutex
	lockTransactionByHash   sync.RWMutex
	lockTransactionReceipt  sync.RWMutex
}

// BalanceAt calls BalanceAtFunc.
func (mock *EthClientMock) BalanceAt(ctx context.Context, account common.Address, blockNumber *big.Int) (*big.Int, error) {
	if mock.BalanceAtFunc == nil {
		panic("EthClientMock.BalanceAtFunc: method is nil but EthClient.BalanceAt was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Account     common.Address
		BlockNumber *big.Int
	}{
		Ctx:         ctx,
		Account:     account,
		BlockNumber: blockNumber,
	}
	mock.lockBalanceAt.Lock()
	mock.calls.BalanceAt = append(mock.calls.BalanceAt, callInfo)
	mock.lockBalanceAt.Unlock()
	return mock.BalanceAtFunc(ctx, account, blockNumber)
}

// BalanceAtCalls gets all the calls that were made to BalanceAt.
// Check the length with:
//
//	len(mockedEthClient.BalanceAtCalls())
func (mock *EthClientMock) BalanceAtCalls() []struct {
	Ctx         context.Context
	Account     common.Address
	BlockNumber *big.Int
} {
	var calls []struct {
		Ctx         context.Context
		Account     common.Address
		BlockNumber *big.Int
	}
	mock.lockBalanceAt.RLock()
	calls = mock.calls.BalanceAt
	mock.lockBalanceAt.RUnlock()
	return calls
}

// BlockByNumber calls BlockByNumberFunc.
func (mock *EthClientMock) BlockByNumber(ctx context.Context, number *big.Int) (*types.Block, error) {
	if mock.BlockByNumberFunc == nil {
		panic("EthClientMock.BlockByNumberFunc: method is nil but EthClient.BlockByNumber was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Number *big.Int
	}{
		Ctx:    ctx,
		Number: number,
	}
	mock.lockBlockByNumber.Lock()
	mock.calls.BlockByNumber = append(mock.calls.BlockByNumber, callInfo)
	mock.lockBlockByNumber.Unlock()
	return mock.BlockByNumberFunc(ctx, number)
}

// BlockByNumberCalls gets all the calls that were made to BlockByNumber.
// Check the length with:
//
//	len(mockedEthClient.BlockByNumberCalls())
func (mock *EthClientMock) BlockByNumberCalls() []struct {
	Ctx    context.Context
	Number *big.Int
} {
	var calls []struct {
		Ctx    context.Context
		Number *big.Int
	}
	mock.lockBlockByNumber.RLock()
	calls = mock.calls.BlockByNumber
	mock.lockBlockByNumber.RUnlock()
	return calls
}

// BlockNumber calls BlockNumberFunc.
func (mock *EthClientMock) BlockNumber(ctx context.Context) (uint64, error) {
	if mock.BlockNumberFunc == nil {
		panic("EthClientMock.BlockNumberFunc: method is nil but EthClient.BlockNumber was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockBlockNumber.Lock()
	mock.calls.BlockNumber = append(mock.calls.BlockNumber, callInfo)
	mock.lockBlockNumber.Unlock()
	return mock.BlockNumberFunc(ctx)
}

// BlockNumberCalls gets all the calls that were made to BlockNumber.
// Check the length with:
//
//	len(mockedEthClient.BlockNumberCalls())
func (mock *EthClientMock) BlockNumberCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockBlockNumber.RLock()
	calls = mock.calls.BlockNumber
	mock.lockBlockNumber.RUnlock()
	return calls
}

// BlockReceipts calls BlockReceiptsFunc.
func (mock *EthClientMock) BlockReceipts(ctx context.Context, blockNrOrHash rpc.BlockNumberOrHash) ([]*types.Receipt, error) {
	if mock.BlockReceiptsFunc == nil {
		panic("EthClientMock.BlockReceiptsFunc: method is nil but EthClient.BlockReceipts was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		BlockNrOrHash rpc.BlockNumberOrHash
	}{
		Ctx:           ctx,
		BlockNrOrHash: blockNrOrHash,
	}
	mock.lockBlockReceipts.Lock()
	mock.calls.BlockReceipts = append(mock.calls.BlockReceipts, callInfo)
	mock.lockBlockReceipts.Unlock()
	return mock.BlockReceiptsFunc(ctx, blockNrOrHash)
}

// BlockReceiptsCalls gets all the calls that were made to BlockReceipts.
// Check the length with:
//
//	len(mockedEthClient.BlockReceiptsCalls())
func (mock *EthClientMock) BlockReceiptsCalls() []struct {
	Ctx           context.Context
	BlockNrOrHash rpc.BlockNumberOrHash
} {
	var calls []struct {
		Ctx           context.Context
		BlockNrOrHash rpc.BlockNumberOrHash
	}
	mock.lockBlockReceipts.RLock()
	calls = mock.calls.BlockReceipts
	mock.lockBlockReceipts.RUnlock()
	return calls
}

// CallContract calls CallContractFunc.
func (mock *EthClientMock) CallContract(ctx context.Context, msg ethereum.CallMsg, blockNumber *big.Int) ([]byte, error) {
	if mock.CallContractFunc == nil {
		panic("EthClientMock.CallContractFunc: method is nil but EthClient.CallContract was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Msg         ethereum.CallMsg
		BlockNumber *big.Int
	}{
		Ctx:         ctx,
		Msg:         msg,
		BlockNumber: blockNumber,
	}
	mock.lockCallContract.Lock()
	mock.calls.CallContract = append(mock.calls.CallContract, callInfo)
	mock.lockCallContract.Unlock()
	return mock.CallContractFunc(ctx, msg, blockNumber)
}

// CallContractCalls gets all the calls that were made to CallContract.
// Check the length with:
//
//	len(mockedEthClient.CallContractCalls())
func (mock *EthClientMock) CallContractCalls() []struct {
	Ctx         context.Context
	Msg         ethereum.CallMsg
	BlockNumber *big.Int
} {
	var calls []struct {
		Ctx         context.Context
		Msg         ethereum.CallMsg
		BlockNumber *big.Int
	}
	mock.lockCallContract.RLock()
	calls = mock.calls.CallContract
	mock.lockCallContract.RUnlock()
	return calls
}

// ChainID calls ChainIDFunc.
func (mock *EthClientMock) ChainID(ctx context.Context) (*big.Int, error) {
	if mock.ChainIDFunc == nil {
		panic("EthClientMock.ChainIDFunc: method is nil but EthClient.ChainID was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockChainID.Lock()
	mock.calls.ChainID = append(mock.calls.ChainID, callInfo)
	mock.lockChainID.Unlock()
	return mock.ChainIDFunc(ctx)
}

// ChainIDCalls gets all the calls that were made to ChainID.
// Check the length with:
//
//	len(mockedEthClient.ChainIDCalls())
func (mock *EthClientMock) ChainIDCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockChainID.RLock()
	calls = mock.calls.ChainID
	mock.lockChainID.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *EthClientMock) Close() error {
	if mock.CloseFunc == nil {
		panic("EthClientMock.CloseFunc: method is nil but EthClient.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedEthClient.CloseCalls())
func (mock *EthClientMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// CodeAt calls CodeAtFunc.
func (mock *EthClientMock) CodeAt(ctx context.Context, account common.Address, blockNumber *big.Int) ([]byte, error) {
	if mock.CodeAtFunc == nil {
		panic("EthClientMock.CodeAtFunc: method is nil but EthClient.CodeAt was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Account     common.Address
		BlockNumber *big.Int
	}{
		Ctx:         ctx,
		Account:     account,
		BlockNumber: blockNumber,
	}
	mock.lockCodeAt.Lock()
	mock.calls.CodeAt = append(mock.calls.CodeAt, callInfo)
	mock.lockCodeAt.Unlock()
	return mock.CodeAtFunc(ctx, account, blockNumber)
}

// CodeAtCalls gets all the calls that were made to CodeAt.
// Check the length with:
//
//	len(mockedEthClient.CodeAtCalls())
func (mock *EthClientMock) CodeAtCalls() []struct {
	Ctx         context.Context
	Account     common.Address
	BlockNumber *big.Int
} {
	var calls []struct {
		Ctx         context.Context
		Account     common.Address
		BlockNumber *big.Int
	}
	mock.lockCodeAt.RLock()
	calls = mock.calls.CodeAt
	mock.lockCodeAt.RUnlock()
	return calls
}

// Dial calls DialFunc.
func (mock *EthClientMock) Dial() error {
	if mock.DialFunc == nil {
		panic("EthClientMock.DialFunc: method is nil but EthClient.Dial was just called")
	}
	callInfo := struct {
	}{}
	mock.lockDial.Lock()
	mock.calls.Dial = append(mock.calls.Dial, callInfo)
	mock.lockDial.Unlock()
	return mock.DialFunc()
}

// DialCalls gets all the calls that were made to Dial.
// Check the length with:
//
//	len(mockedEthClient.DialCalls())
func (mock *EthClientMock) DialCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDial.RLock()
	calls = mock.calls.Dial
	mock.lockDial.RUnlock()
	return calls
}

// EstimateGas calls EstimateGasFunc.
func (mock *EthClientMock) EstimateGas(ctx context.Context, msg ethereum.CallMsg) (uint64, error) {
	if mock.EstimateGasFunc == nil {
		panic("EthClientMock.EstimateGasFunc: method is nil but EthClient.EstimateGas was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Msg ethereum.CallMsg
	}{
		Ctx: ctx,
		Msg: msg,
	}
	mock.lockEstimateGas.Lock()
	mock.calls.EstimateGas = append(mock.calls.EstimateGas, callInfo)
	mock.lockEstimateGas.Unlock()
	return mock.EstimateGasFunc(ctx, msg)
}

// EstimateGasCalls gets all the calls that were made to EstimateGas.
// Check the length with:
//
//	len(mockedEthClient.EstimateGasCalls())
func (mock *EthClientMock) EstimateGasCalls() []struct {
	Ctx context.Context
	Msg ethereum.CallMsg
} {
	var calls []struct {
		Ctx context.Context
		Msg ethereum.CallMsg
	}
	mock.lockEstimateGas.RLock()
	calls = mock.calls.EstimateGas
	mock.lockEstimateGas.RUnlock()
	return calls
}

// FilterLogs calls FilterLogsFunc.
func (mock *EthClientMock) FilterLogs(ctx context.Context, q ethereum.FilterQuery) ([]types.Log, error) {
	if mock.FilterLogsFunc == nil {
		panic("EthClientMock.FilterLogsFunc: method is nil but EthClient.FilterLogs was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Q   ethereum.FilterQuery
	}{
		Ctx: ctx,
		Q:   q,
	}
	mock.lockFilterLogs.Lock()
	mock.calls.FilterLogs = append(mock.calls.FilterLogs, callInfo)
	mock.lockFilterLogs.Unlock()
	return mock.FilterLogsFunc(ctx, q)
}

// FilterLogsCalls gets all the calls that were made to FilterLogs.
// Check the length with:
//
//	len(mockedEthClient.FilterLogsCalls())
func (mock *EthClientMock) FilterLogsCalls() []struct {
	Ctx context.Context
	Q   ethereum.FilterQuery
} {
	var calls []struct {
		Ctx context.Context
		Q   ethereum.FilterQuery
	}
	mock.lockFilterLogs.RLock()
	calls = mock.calls.FilterLogs
	mock.lockFilterLogs.RUnlock()
	return calls
}

// HeaderByNumber calls HeaderByNumberFunc.
func (mock *EthClientMock) HeaderByNumber(ctx context.Context, number *big.Int) (*types.Header, error) {
	if mock.HeaderByNumberFunc == nil {
		panic("EthClientMock.HeaderByNumberFunc: method is nil but EthClient.HeaderByNumber was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Number *big.Int
	}{
		Ctx:    ctx,
		Number: number,
	}
	mock.lockHeaderByNumber.Lock()
	mock.calls.HeaderByNumber = append(mock.calls.HeaderByNumber, callInfo)
	mock.lockHeaderByNumber.Unlock()
	return mock.HeaderByNumberFunc(ctx, number)
}

// HeaderByNumberCalls gets all the calls that were made to HeaderByNumber.
// Check the length with:
//
//	len(mockedEthClient.HeaderByNumberCalls())
func (mock *EthClientMock) HeaderByNumberCalls() []struct {
	Ctx    context.Context
	Number *big.Int
} {
	var calls []struct {
		Ctx    context.Context
		Number *big.Int
	}
	mock.lockHeaderByNumber.RLock()
	calls = mock.calls.HeaderByNumber
	mock.lockHeaderByNumber.RUnlock()
	return calls
}

// PendingCodeAt calls PendingCodeAtFunc.
func (mock *EthClientMock) PendingCodeAt(ctx context.Context, account common.Address) ([]byte, error) {
	if mock.PendingCodeAtFunc == nil {
		panic("EthClientMock.PendingCodeAtFunc: method is nil but EthClient.PendingCodeAt was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Account common.Address
	}{
		Ctx:     ctx,
		Account: account,
	}
	mock.lockPendingCodeAt.Lock()
	mock.calls.PendingCodeAt = append(mock.calls.PendingCodeAt, callInfo)
	mock.lockPendingCodeAt.Unlock()
	return mock.PendingCodeAtFunc(ctx, account)
}

// PendingCodeAtCalls gets all the calls that were made to PendingCodeAt.
// Check the length with:
//
//	len(mockedEthClient.PendingCodeAtCalls())
func (mock *EthClientMock) PendingCodeAtCalls() []struct {
	Ctx     context.Context
	Account common.Address
} {
	var calls []struct {
		Ctx     context.Context
		Account common.Address
	}
	mock.lockPendingCodeAt.RLock()
	calls = mock.calls.PendingCodeAt
	mock.lockPendingCodeAt.RUnlock()
	return calls
}

// PendingNonceAt calls PendingNonceAtFunc.
func (mock *EthClientMock) PendingNonceAt(ctx context.Context, account common.Address) (uint64, error) {
	if mock.PendingNonceAtFunc == nil {
		panic("EthClientMock.PendingNonceAtFunc: method is nil but EthClient.PendingNonceAt was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Account common.Address
	}{
		Ctx:     ctx,
		Account: account,
	}
	mock.lockPendingNonceAt.Lock()
	mock.calls.PendingNonceAt = append(mock.calls.PendingNonceAt, callInfo)
	mock.lockPendingNonceAt.Unlock()
	return mock.PendingNonceAtFunc(ctx, account)
}

// PendingNonceAtCalls gets all the calls that were made to PendingNonceAt.
// Check the length with:
//
//	len(mockedEthClient.PendingNonceAtCalls())
func (mock *EthClientMock) PendingNonceAtCalls() []struct {
	Ctx     context.Context
	Account common.Address
} {
	var calls []struct {
		Ctx     context.Context
		Account common.Address
	}
	mock.lockPendingNonceAt.RLock()
	calls = mock.calls.PendingNonceAt
	mock.lockPendingNonceAt.RUnlock()
	return calls
}

// SendTransaction calls SendTransactionFunc.
func (mock *EthClientMock) SendTransaction(ctx context.Context, tx *types.Transaction) error {
	if mock.SendTransactionFunc == nil {
		panic("EthClientMock.SendTransactionFunc: method is nil but EthClient.SendTransaction was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Tx  *types.Transaction
	}{
		Ctx: ctx,
		Tx:  tx,
	}
	mock.lockSendTransaction.Lock()
	mock.calls.SendTransaction = append(mock.calls.SendTransaction, callInfo)
	mock.lockSendTransaction.Unlock()
	return mock.SendTransactionFunc(ctx, tx)
}

// SendTransactionCalls gets all the calls that were made to SendTransaction.
// Check the length with:
//
//	len(mockedEthClient.SendTransactionCalls())
func (mock *EthClientMock) SendTransactionCalls() []struct {
	Ctx context.Context
	Tx  *types.Transaction
} {
	var calls []struct {
		Ctx context.Context
		Tx  *types.Transaction
	}
	mock.lockSendTransaction.RLock()
	calls = mock.calls.SendTransaction
	mock.lockSendTransaction.RUnlock()
	return calls
}

// SubscribeFilterLogs calls SubscribeFilterLogsFunc.
func (mock *EthClientMock) SubscribeFilterLogs(ctx context.Context, q ethereum.FilterQuery, ch chan<- types.Log) (ethereum.Subscription, error) {
	if mock.SubscribeFilterLogsFunc == nil {
		panic("EthClientMock.SubscribeFilterLogsFunc: method is nil but EthClient.SubscribeFilterLogs was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Q   ethereum.FilterQuery
		Ch  chan<- types.Log
	}{
		Ctx: ctx,
		Q:   q,
		Ch:  ch,
	}
	mock.lockSubscribeFilterLogs.Lock()
	mock.calls.SubscribeFilterLogs = append(mock.calls.SubscribeFilterLogs, callInfo)
	mock.lockSubscribeFilterLogs.Unlock()
	return mock.SubscribeFilterLogsFunc(ctx, q, ch)
}

// SubscribeFilterLogsCalls gets all the calls that were made to SubscribeFilterLogs.
// Check the length with:
//
//	len(mockedEthClient.SubscribeFilterLogsCalls())
func (mock *EthClientMock) SubscribeFilterLogsCalls() []struct {
	Ctx context.Context
	Q   ethereum.FilterQuery
	Ch  chan<- types.Log
} {
	var calls []struct {
		Ctx context.Context
		Q   ethereum.FilterQuery
		Ch  chan<- types.Log
	}
	mock.lockSubscribeFilterLogs.RLock()
	calls = mock.calls.SubscribeFilterLogs
	mock.lockSubscribeFilterLogs.RUnlock()
	return calls
}

// SubscribeNewHead calls SubscribeNewHeadFunc.
func (mock *EthClientMock) SubscribeNewHead(ctx context.Context) (chan *types.Header, ethereum.Subscription, error) {
	if mock.SubscribeNewHeadFunc == nil {
		panic("EthClientMock.SubscribeNewHeadFunc: method is nil but EthClient.SubscribeNewHead was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockSubscribeNewHead.Lock()
	mock.calls.SubscribeNewHead = append(mock.calls.SubscribeNewHead, callInfo)
	mock.lockSubscribeNewHead.Unlock()
	return mock.SubscribeNewHeadFunc(ctx)
}

// SubscribeNewHeadCalls gets all the calls that were made to SubscribeNewHead.
// Check the length with:
//
//	len(mockedEthClient.SubscribeNewHeadCalls())
func (mock *EthClientMock) SubscribeNewHeadCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockSubscribeNewHead.RLock()
	calls = mock.calls.SubscribeNewHead
	mock.lockSubscribeNewHead.RUnlock()
	return calls
}

// SuggestGasPrice calls SuggestGasPriceFunc.
func (mock *EthClientMock) SuggestGasPrice(ctx context.Context) (*big.Int, error) {
	if mock.SuggestGasPriceFunc == nil {
		panic("EthClientMock.SuggestGasPriceFunc: method is nil but EthClient.SuggestGasPrice was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockSuggestGasPrice.Lock()
	mock.calls.SuggestGasPrice = append(mock.calls.SuggestGasPrice, callInfo)
	mock.lockSuggestGasPrice.Unlock()
	return mock.SuggestGasPriceFunc(ctx)
}

// SuggestGasPriceCalls gets all the calls that were made to SuggestGasPrice.
// Check the length with:
//
//	len(mockedEthClient.SuggestGasPriceCalls())
func (mock *EthClientMock) SuggestGasPriceCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockSuggestGasPrice.RLock()
	calls = mock.calls.SuggestGasPrice
	mock.lockSuggestGasPrice.RUnlock()
	return calls
}

// SuggestGasTipCap calls SuggestGasTipCapFunc.
func (mock *EthClientMock) SuggestGasTipCap(ctx context.Context) (*big.Int, error) {
	if mock.SuggestGasTipCapFunc == nil {
		panic("EthClientMock.SuggestGasTipCapFunc: method is nil but EthClient.SuggestGasTipCap was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockSuggestGasTipCap.Lock()
	mock.calls.SuggestGasTipCap = append(mock.calls.SuggestGasTipCap, callInfo)
	mock.lockSuggestGasTipCap.Unlock()
	return mock.SuggestGasTipCapFunc(ctx)
}

// SuggestGasTipCapCalls gets all the calls that were made to SuggestGasTipCap.
// Check the length with:
//
//	len(mockedEthClient.SuggestGasTipCapCalls())
func (mock *EthClientMock) SuggestGasTipCapCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockSuggestGasTipCap.RLock()
	calls = mock.calls.SuggestGasTipCap
	mock.lockSuggestGasTipCap.RUnlock()
	return calls
}

// TransactionByHash calls TransactionByHashFunc.
func (mock *EthClientMock) TransactionByHash(ctx context.Context, hash common.Hash) (*types.Transaction, bool, error) {
	if mock.TransactionByHashFunc == nil {
		panic("EthClientMock.TransactionByHashFunc: method is nil but EthClient.TransactionByHash was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Hash common.Hash
	}{
		Ctx:  ctx,
		Hash: hash,
	}
	mock.lockTransactionByHash.Lock()
	mock.calls.TransactionByHash = append(mock.calls.TransactionByHash, callInfo)
	mock.lockTransactionByHash.Unlock()
	return mock.TransactionByHashFunc(ctx, hash)
}

// TransactionByHashCalls gets all the calls that were made to TransactionByHash.
// Check the length with:
//
//	len(mockedEthClient.TransactionByHashCalls())
func (mock *EthClientMock) TransactionByHashCalls() []struct {
	Ctx  context.Context
	Hash common.Hash
} {
	var calls []struct {
		Ctx  context.Context
		Hash common.Hash
	}
	mock.lockTransactionByHash.RLock()
	calls = mock.calls.TransactionByHash
	mock.lockTransactionByHash.RUnlock()
	return calls
}

// TransactionReceipt calls TransactionReceiptFunc.
func (mock *EthClientMock) TransactionReceipt(ctx context.Context, txHash common.Hash) (*types.Receipt, error) {
	if mock.TransactionReceiptFunc == nil {
		panic("EthClientMock.TransactionReceiptFunc: method is nil but EthClient.TransactionReceipt was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		TxHash common.Hash
	}{
		Ctx:    ctx,
		TxHash: txHash,
	}
	mock.lockTransactionReceipt.Lock()
	mock.calls.TransactionReceipt = append(mock.calls.TransactionReceipt, callInfo)
	mock.lockTransactionReceipt.Unlock()
	return mock.TransactionReceiptFunc(ctx, txHash)
}

// TransactionReceiptCalls gets all the calls that were made to TransactionReceipt.
// Check the length with:
//
//	len(mockedEthClient.TransactionReceiptCalls())
func (mock *EthClientMock) TransactionReceiptCalls() []struct {
	Ctx    context.Context
	TxHash common.Hash
} {
	var calls []struct {
		Ctx    context.Context
		TxHash common.Hash
	}
	mock.lockTransactionReceipt.RLock()
	calls = mock.calls.TransactionReceipt
	mock.lockTransactionReceipt.RUnlock()
	return calls
}

// Ensure, that LoggerMock does implement Logger.
// If this is not the case, regenerate this file with moq.
var _ Logger = &LoggerMock{}

// LoggerMock is a mock implementation of Logger.
//
//	func TestSomethingThatUsesLogger(t *testing.T) {
//
//		// make and configure a mocked Logger
//		mockedLogger := &LoggerMock{
//			DebugFunc: func(msg string, keyVals ...any)  {
//				panic("mock out the Debug method")
//			},
//			ErrorFunc: func(msg string, keyVals ...any)  {
//				panic("mock out the Error method")
//			},
//			ImplFunc: func() any {
//				panic("mock out the Impl method")
//			},
//			InfoFunc: func(msg string, keyVals ...any)  {
//				panic("mock out the Info method")
//			},
//			WarnFunc: func(msg string, keyVals ...any)  {
//				panic("mock out the Warn method")
//			},
//			WithFunc: func(keyVals ...any) log.Logger {
//				panic("mock out the With method")
//			},
//		}
//
//		// use mockedLogger in code that requires Logger
//		// and then make assertions.
//
//	}
type LoggerMock struct {
	// DebugFunc mocks the Debug method.
	DebugFunc func(msg string, keyVals ...any)

	// ErrorFunc mocks the Error method.
	ErrorFunc func(msg string, keyVals ...any)

	// ImplFunc mocks the Impl method.
	ImplFunc func() any

	// InfoFunc mocks the Info method.
	InfoFunc func(msg string, keyVals ...any)

	// WarnFunc mocks the Warn method.
	WarnFunc func(msg string, keyVals ...any)

	// WithFunc mocks the With method.
	WithFunc func(keyVals ...any) log.Logger

	// calls tracks calls to the methods.
	calls struct {
		// Debug holds details about calls to the Debug method.
		Debug []struct {
			// Msg is the msg argument value.
			Msg string
			// KeyVals is the keyVals argument value.
			KeyVals []any
		}
		// Error holds details about calls to the Error method.
		Error []struct {
			// Msg is the msg argument value.
			Msg string
			// KeyVals is the keyVals argument value.
			KeyVals []any
		}
		// Impl holds details about calls to the Impl method.
		Impl []struct {
		}
		// Info holds details about calls to the Info method.
		Info []struct {
			// Msg is the msg argument value.
			Msg string
			// KeyVals is the keyVals argument value.
			KeyVals []any
		}
		// Warn holds details about calls to the Warn method.
		Warn []struct {
			// Msg is the msg argument value.
			Msg string
			// KeyVals is the keyVals argument value.
			KeyVals []any
		}
		// With holds details about calls to the With method.
		With []struct {
			// KeyVals is the keyVals argument value.
			KeyVals []any
		}
	}
	lockDebug sync.RWMutex
	lockError sync.RWMutex
	lockImpl  sync.RWMutex
	lockInfo  sync.RWMutex
	lockWarn  sync.RWMutex
	lockWith  sync.RWMutex
}

// Debug calls DebugFunc.
func (mock *LoggerMock) Debug(msg string, keyVals ...any) {
	if mock.DebugFunc == nil {
		panic("LoggerMock.DebugFunc: method is nil but Logger.Debug was just called")
	}
	callInfo := struct {
		Msg     string
		KeyVals []any
	}{
		Msg:     msg,
		KeyVals: keyVals,
	}
	mock.lockDebug.Lock()
	mock.calls.Debug = append(mock.calls.Debug, callInfo)
	mock.lockDebug.Unlock()
	mock.DebugFunc(msg, keyVals...)
}

// DebugCalls gets all the calls that were made to Debug.
// Check the length with:
//
//	len(mockedLogger.DebugCalls())
func (mock *LoggerMock) DebugCalls() []struct {
	Msg     string
	KeyVals []any
} {
	var calls []struct {
		Msg     string
		KeyVals []any
	}
	mock.lockDebug.RLock()
	calls = mock.calls.Debug
	mock.lockDebug.RUnlock()
	return calls
}

// Error calls ErrorFunc.
func (mock *LoggerMock) Error(msg string, keyVals ...any) {
	if mock.ErrorFunc == nil {
		panic("LoggerMock.ErrorFunc: method is nil but Logger.Error was just called")
	}
	callInfo := struct {
		Msg     string
		KeyVals []any
	}{
		Msg:     msg,
		KeyVals: keyVals,
	}
	mock.lockError.Lock()
	mock.calls.Error = append(mock.calls.Error, callInfo)
	mock.lockError.Unlock()
	mock.ErrorFunc(msg, keyVals...)
}

// ErrorCalls gets all the calls that were made to Error.
// Check the length with:
//
//	len(mockedLogger.ErrorCalls())
func (mock *LoggerMock) ErrorCalls() []struct {
	Msg     string
	KeyVals []any
} {
	var calls []struct {
		Msg     string
		KeyVals []any
	}
	mock.lockError.RLock()
	calls = mock.calls.Error
	mock.lockError.RUnlock()
	return calls
}

// Impl calls ImplFunc.
func (mock *LoggerMock) Impl() any {
	if mock.ImplFunc == nil {
		panic("LoggerMock.ImplFunc: method is nil but Logger.Impl was just called")
	}
	callInfo := struct {
	}{}
	mock.lockImpl.Lock()
	mock.calls.Impl = append(mock.calls.Impl, callInfo)
	mock.lockImpl.Unlock()
	return mock.ImplFunc()
}

// ImplCalls gets all the calls that were made to Impl.
// Check the length with:
//
//	len(mockedLogger.ImplCalls())
func (mock *LoggerMock) ImplCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockImpl.RLock()
	calls = mock.calls.Impl
	mock.lockImpl.RUnlock()
	return calls
}

// Info calls InfoFunc.
func (mock *LoggerMock) Info(msg string, keyVals ...any) {
	if mock.InfoFunc == nil {
		panic("LoggerMock.InfoFunc: method is nil but Logger.Info was just called")
	}
	callInfo := struct {
		Msg     string
		KeyVals []any
	}{
		Msg:     msg,
		KeyVals: keyVals,
	}
	mock.lockInfo.Lock()
	mock.calls.Info = append(mock.calls.Info, callInfo)
	mock.lockInfo.Unlock()
	mock.InfoFunc(msg, keyVals...)
}

// InfoCalls gets all the calls that were made to Info.
// Check the length with:
//
//	len(mockedLogger.InfoCalls())
func (mock *LoggerMock) InfoCalls() []struct {
	Msg     string
	KeyVals []any
} {
	var calls []struct {
		Msg     string
		KeyVals []any
	}
	mock.lockInfo.RLock()
	calls = mock.calls.Info
	mock.lockInfo.RUnlock()
	return calls
}

// Warn calls WarnFunc.
func (mock *LoggerMock) Warn(msg string, keyVals ...any) {
	if mock.WarnFunc == nil {
		panic("LoggerMock.WarnFunc: method is nil but Logger.Warn was just called")
	}
	callInfo := struct {
		Msg     string
		KeyVals []any
	}{
		Msg:     msg,
		KeyVals: keyVals,
	}
	mock.lockWarn.Lock()
	mock.calls.Warn = append(mock.calls.Warn, callInfo)
	mock.lockWarn.Unlock()
	mock.WarnFunc(msg, keyVals...)
}

// WarnCalls gets all the calls that were made to Warn.
// Check the length with:
//
//	len(mockedLogger.WarnCalls())
func (mock *LoggerMock) WarnCalls() []struct {
	Msg     string
	KeyVals []any
} {
	var calls []struct {
		Msg     string
		KeyVals []any
	}
	mock.lockWarn.RLock()
	calls = mock.calls.Warn
	mock.lockWarn.RUnlock()
	return calls
}

// With calls WithFunc.
func (mock *LoggerMock) With(keyVals ...any) log.Logger {
	if mock.WithFunc == nil {
		panic("LoggerMock.WithFunc: method is nil but Logger.With was just called")
	}
	callInfo := struct {
		KeyVals []any
	}{
		KeyVals: keyVals,
	}
	mock.lockWith.Lock()
	mock.calls.With = append(mock.calls.With, callInfo)
	mock.lockWith.Unlock()
	return mock.WithFunc(keyVals...)
}

// WithCalls gets all the calls that were made to With.
// Check the length with:
//
//	len(mockedLogger.WithCalls())
func (mock *LoggerMock) WithCalls() []struct {
	KeyVals []any
} {
	var calls []struct {
		KeyVals []any
	}
	mock.lockWith.RLock()
	calls = mock.calls.With
	mock.lockWith.RUnlock()
	return calls
}

// Ensure, that KeyValueStoreMock does implement KeyValueStore.
// If this is not the case, regenerate this file with moq.
var _ KeyValueStore = &KeyValueStoreMock{}

// KeyValueStoreMock is a mock implementation of KeyValueStore.
//
//	func TestSomethingThatUsesKeyValueStore(t *testing.T) {
//
//		// make and configure a mocked KeyValueStore
//		mockedKeyValueStore := &KeyValueStoreMock{
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			CompactFunc: func(start []byte, limit []byte) error {
//				panic("mock out the Compact method")
//			},
//			DeleteFunc: func(key []byte) error {
//				panic("mock out the Delete method")
//			},
//			GetFunc: func(key []byte) ([]byte, error) {
//				panic("mock out the Get method")
//			},
//			HasFunc: func(key []byte) (bool, error) {
//				panic("mock out the Has method")
//			},
//			NewBatchFunc: func() ethdb.Batch {
//				panic("mock out the NewBatch method")
//			},
//			NewBatchWithSizeFunc: func(size int) ethdb.Batch {
//				panic("mock out the NewBatchWithSize method")
//			},
//			NewIteratorFunc: func(prefix []byte, start []byte) ethdb.Iterator {
//				panic("mock out the NewIterator method")
//			},
//			NewSnapshotFunc: func() (ethdb.Snapshot, error) {
//				panic("mock out the NewSnapshot method")
//			},
//			PutFunc: func(key []byte, value []byte) error {
//				panic("mock out the Put method")
//			},
//			StatFunc: func(property string) (string, error) {
//				panic("mock out the Stat method")
//			},
//		}
//
//		// use mockedKeyValueStore in code that requires KeyValueStore
//		// and then make assertions.
//
//	}
type KeyValueStoreMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// CompactFunc mocks the Compact method.
	CompactFunc func(start []byte, limit []byte) error

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(key []byte) error

	// GetFunc mocks the Get method.
	GetFunc func(key []byte) ([]byte, error)

	// HasFunc mocks the Has method.
	HasFunc func(key []byte) (bool, error)

	// NewBatchFunc mocks the NewBatch method.
	NewBatchFunc func() ethdb.Batch

	// NewBatchWithSizeFunc mocks the NewBatchWithSize method.
	NewBatchWithSizeFunc func(size int) ethdb.Batch

	// NewIteratorFunc mocks the NewIterator method.
	NewIteratorFunc func(prefix []byte, start []byte) ethdb.Iterator

	// NewSnapshotFunc mocks the NewSnapshot method.
	NewSnapshotFunc func() (ethdb.Snapshot, error)

	// PutFunc mocks the Put method.
	PutFunc func(key []byte, value []byte) error

	// StatFunc mocks the Stat method.
	StatFunc func(property string) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Compact holds details about calls to the Compact method.
		Compact []struct {
			// Start is the start argument value.
			Start []byte
			// Limit is the limit argument value.
			Limit []byte
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Key is the key argument value.
			Key []byte
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Key is the key argument value.
			Key []byte
		}
		// Has holds details about calls to the Has method.
		Has []struct {
			// Key is the key argument value.
			Key []byte
		}
		// NewBatch holds details about calls to the NewBatch method.
		NewBatch []struct {
		}
		// NewBatchWithSize holds details about calls to the NewBatchWithSize method.
		NewBatchWithSize []struct {
			// Size is the size argument value.
			Size int
		}
		// NewIterator holds details about calls to the NewIterator method.
		NewIterator []struct {
			// Prefix is the prefix argument value.
			Prefix []byte
			// Start is the start argument value.
			Start []byte
		}
		// NewSnapshot holds details about calls to the NewSnapshot method.
		NewSnapshot []struct {
		}
		// Put holds details about calls to the Put method.
		Put []struct {
			// Key is the key argument value.
			Key []byte
			// Value is the value argument value.
			Value []byte
		}
		// Stat holds details about calls to the Stat method.
		Stat []struct {
			// Property is the property argument value.
			Property string
		}
	}
	lockClose            sync.RWMutex
	lockCompact          sync.RWMutex
	lockDelete           sync.RWMutex
	lockGet              sync.RWMutex
	lockHas              sync.RWMutex
	lockNewBatch         sync.RWMutex
	lockNewBatchWithSize sync.RWMutex
	lockNewIterator      sync.RWMutex
	lockNewSnapshot      sync.RWMutex
	lockPut              sync.RWMutex
	lockStat             sync.RWMutex
}

// Close calls CloseFunc.
func (mock *KeyValueStoreMock) Close() error {
	if mock.CloseFunc == nil {
		panic("KeyValueStoreMock.CloseFunc: method is nil but KeyValueStore.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedKeyValueStore.CloseCalls())
func (mock *KeyValueStoreMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Compact calls CompactFunc.
func (mock *KeyValueStoreMock) Compact(start []byte, limit []byte) error {
	if mock.CompactFunc == nil {
		panic("KeyValueStoreMock.CompactFunc: method is nil but KeyValueStore.Compact was just called")
	}
	callInfo := struct {
		Start []byte
		Limit []byte
	}{
		Start: start,
		Limit: limit,
	}
	mock.lockCompact.Lock()
	mock.calls.Compact = append(mock.calls.Compact, callInfo)
	mock.lockCompact.Unlock()
	return mock.CompactFunc(start, limit)
}

// CompactCalls gets all the calls that were made to Compact.
// Check the length with:
//
//	len(mockedKeyValueStore.CompactCalls())
func (mock *KeyValueStoreMock) CompactCalls() []struct {
	Start []byte
	Limit []byte
} {
	var calls []struct {
		Start []byte
		Limit []byte
	}
	mock.lockCompact.RLock()
	calls = mock.calls.Compact
	mock.lockCompact.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *KeyValueStoreMock) Delete(key []byte) error {
	if mock.DeleteFunc == nil {
		panic("KeyValueStoreMock.DeleteFunc: method is nil but KeyValueStore.Delete was just called")
	}
	callInfo := struct {
		Key []byte
	}{
		Key: key,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(key)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedKeyValueStore.DeleteCalls())
func (mock *KeyValueStoreMock) DeleteCalls() []struct {
	Key []byte
} {
	var calls []struct {
		Key []byte
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *KeyValueStoreMock) Get(key []byte) ([]byte, error) {
	if mock.GetFunc == nil {
		panic("KeyValueStoreMock.GetFunc: method is nil but KeyValueStore.Get was just called")
	}
	callInfo := struct {
		Key []byte
	}{
		Key: key,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(key)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedKeyValueStore.GetCalls())
func (mock *KeyValueStoreMock) GetCalls() []struct {
	Key []byte
} {
	var calls []struct {
		Key []byte
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// Has calls HasFunc.
func (mock *KeyValueStoreMock) Has(key []byte) (bool, error) {
	if mock.HasFunc == nil {
		panic("KeyValueStoreMock.HasFunc: method is nil but KeyValueStore.Has was just called")
	}
	callInfo := struct {
		Key []byte
	}{
		Key: key,
	}
	mock.lockHas.Lock()
	mock.calls.Has = append(mock.calls.Has, callInfo)
	mock.lockHas.Unlock()
	return mock.HasFunc(key)
}

// HasCalls gets all the calls that were made to Has.
// Check the length with:
//
//	len(mockedKeyValueStore.HasCalls())
func (mock *KeyValueStoreMock) HasCalls() []struct {
	Key []byte
} {
	var calls []struct {
		Key []byte
	}
	mock.lockHas.RLock()
	calls = mock.calls.Has
	mock.lockHas.RUnlock()
	return calls
}

// NewBatch calls NewBatchFunc.
func (mock *KeyValueStoreMock) NewBatch() ethdb.Batch {
	if mock.NewBatchFunc == nil {
		panic("KeyValueStoreMock.NewBatchFunc: method is nil but KeyValueStore.NewBatch was just called")
	}
	callInfo := struct {
	}{}
	mock.lockNewBatch.Lock()
	mock.calls.NewBatch = append(mock.calls.NewBatch, callInfo)
	mock.lockNewBatch.Unlock()
	return mock.NewBatchFunc()
}

// NewBatchCalls gets all the calls that were made to NewBatch.
// Check the length with:
//
//	len(mockedKeyValueStore.NewBatchCalls())
func (mock *KeyValueStoreMock) NewBatchCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockNewBatch.RLock()
	calls = mock.calls.NewBatch
	mock.lockNewBatch.RUnlock()
	return calls
}

// NewBatchWithSize calls NewBatchWithSizeFunc.
func (mock *KeyValueStoreMock) NewBatchWithSize(size int) ethdb.Batch {
	if mock.NewBatchWithSizeFunc == nil {
		panic("KeyValueStoreMock.NewBatchWithSizeFunc: method is nil but KeyValueStore.NewBatchWithSize was just called")
	}
	callInfo := struct {
		Size int
	}{
		Size: size,
	}
	mock.lockNewBatchWithSize.Lock()
	mock.calls.NewBatchWithSize = append(mock.calls.NewBatchWithSize, callInfo)
	mock.lockNewBatchWithSize.Unlock()
	return mock.NewBatchWithSizeFunc(size)
}

// NewBatchWithSizeCalls gets all the calls that were made to NewBatchWithSize.
// Check the length with:
//
//	len(mockedKeyValueStore.NewBatchWithSizeCalls())
func (mock *KeyValueStoreMock) NewBatchWithSizeCalls() []struct {
	Size int
} {
	var calls []struct {
		Size int
	}
	mock.lockNewBatchWithSize.RLock()
	calls = mock.calls.NewBatchWithSize
	mock.lockNewBatchWithSize.RUnlock()
	return calls
}

// NewIterator calls NewIteratorFunc.
func (mock *KeyValueStoreMock) NewIterator(prefix []byte, start []byte) ethdb.Iterator {
	if mock.NewIteratorFunc == nil {
		panic("KeyValueStoreMock.NewIteratorFunc: method is nil but KeyValueStore.NewIterator was just called")
	}
	callInfo := struct {
		Prefix []byte
		Start  []byte
	}{
		Prefix: prefix,
		Start:  start,
	}
	mock.lockNewIterator.Lock()
	mock.calls.NewIterator = append(mock.calls.NewIterator, callInfo)
	mock.lockNewIterator.Unlock()
	return mock.NewIteratorFunc(prefix, start)
}

// NewIteratorCalls gets all the calls that were made to NewIterator.
// Check the length with:
//
//	len(mockedKeyValueStore.NewIteratorCalls())
func (mock *KeyValueStoreMock) NewIteratorCalls() []struct {
	Prefix []byte
	Start  []byte
} {
	var calls []struct {
		Prefix []byte
		Start  []byte
	}
	mock.lockNewIterator.RLock()
	calls = mock.calls.NewIterator
	mock.lockNewIterator.RUnlock()
	return calls
}

// NewSnapshot calls NewSnapshotFunc.
func (mock *KeyValueStoreMock) NewSnapshot() (ethdb.Snapshot, error) {
	if mock.NewSnapshotFunc == nil {
		panic("KeyValueStoreMock.NewSnapshotFunc: method is nil but KeyValueStore.NewSnapshot was just called")
	}
	callInfo := struct {
	}{}
	mock.lockNewSnapshot.Lock()
	mock.calls.NewSnapshot = append(mock.calls.NewSnapshot, callInfo)
	mock.lockNewSnapshot.Unlock()
	return mock.NewSnapshotFunc()
}

// NewSnapshotCalls gets all the calls that were made to NewSnapshot.
// Check the length with:
//
//	len(mockedKeyValueStore.NewSnapshotCalls())
func (mock *KeyValueStoreMock) NewSnapshotCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockNewSnapshot.RLock()
	calls = mock.calls.NewSnapshot
	mock.lockNewSnapshot.RUnlock()
	return calls
}

// Put calls PutFunc.
func (mock *KeyValueStoreMock) Put(key []byte, value []byte) error {
	if mock.PutFunc == nil {
		panic("KeyValueStoreMock.PutFunc: method is nil but KeyValueStore.Put was just called")
	}
	callInfo := struct {
		Key   []byte
		Value []byte
	}{
		Key:   key,
		Value: value,
	}
	mock.lockPut.Lock()
	mock.calls.Put = append(mock.calls.Put, callInfo)
	mock.lockPut.Unlock()
	return mock.PutFunc(key, value)
}

// PutCalls gets all the calls that were made to Put.
// Check the length with:
//
//	len(mockedKeyValueStore.PutCalls())
func (mock *KeyValueStoreMock) PutCalls() []struct {
	Key   []byte
	Value []byte
} {
	var calls []struct {
		Key   []byte
		Value []byte
	}
	mock.lockPut.RLock()
	calls = mock.calls.Put
	mock.lockPut.RUnlock()
	return calls
}

// Stat calls StatFunc.
func (mock *KeyValueStoreMock) Stat(property string) (string, error) {
	if mock.StatFunc == nil {
		panic("KeyValueStoreMock.StatFunc: method is nil but KeyValueStore.Stat was just called")
	}
	callInfo := struct {
		Property string
	}{
		Property: property,
	}
	mock.lockStat.Lock()
	mock.calls.Stat = append(mock.calls.Stat, callInfo)
	mock.lockStat.Unlock()
	return mock.StatFunc(property)
}

// StatCalls gets all the calls that were made to Stat.
// Check the length with:
//
//	len(mockedKeyValueStore.StatCalls())
func (mock *KeyValueStoreMock) StatCalls() []struct {
	Property string
} {
	var calls []struct {
		Property string
	}
	mock.lockStat.RLock()
	calls = mock.calls.Stat
	mock.lockStat.RUnlock()
	return calls
}
